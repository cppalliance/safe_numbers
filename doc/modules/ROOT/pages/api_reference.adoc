////
Copyright 2026 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#api_reference]
= API Reference
:idprefix: api_ref_

[#api_types]
== Types

=== Unsigned Integer Types

[cols="1,2", options="header"]
|===
| Type | Description

| xref:unsigned_integers.adoc[`u8`]
| Safe unsigned 8-bit integer

| xref:unsigned_integers.adoc[`u16`]
| Safe unsigned 16-bit integer

| xref:unsigned_integers.adoc[`u32`]
| Safe unsigned 32-bit integer

| xref:unsigned_integers.adoc[`u64`]
| Safe unsigned 64-bit integer

| xref:unsigned_integers.adoc[`u128`]
| Safe unsigned 128-bit integer
|===

=== Bounded Unsigned Integer Type

[cols="1,2", options="header"]
|===
| Type | Description

| xref:bounded_uint.adoc[`bounded_uint<Min, Max>`]
| Safe unsigned integer constrained to a compile-time range `[Min, Max]`
|===

=== Verified Integer Types

[cols="1,2", options="header"]
|===
| Type | Description

| xref:verified_integers.adoc[`verified_u8`]
| Compile-time verified safe unsigned 8-bit integer

| xref:verified_integers.adoc[`verified_u16`]
| Compile-time verified safe unsigned 16-bit integer

| xref:verified_integers.adoc[`verified_u32`]
| Compile-time verified safe unsigned 32-bit integer

| xref:verified_integers.adoc[`verified_u64`]
| Compile-time verified safe unsigned 64-bit integer

| xref:verified_integers.adoc[`verified_u128`]
| Compile-time verified safe unsigned 128-bit integer

| xref:verified_integers.adoc[`verified_bounded_integer<Min, Max>`]
| Compile-time verified bounded unsigned integer constrained to `[Min, Max]`
|===

=== Enumerations

[cols="1,2", options="header"]
|===
| Type | Description

| xref:policies.adoc[`overflow_policy`]
| Enum class specifying the overflow handling policy for arithmetic operations
|===

[#api_functions]
== Functions

=== Character Conversion

[cols="1,2", options="header"]
|===
| Function | Description

| xref:charconv.adoc[`to_chars`]
| Converts a safe integer to a character string

| xref:charconv.adoc[`from_chars`]
| Parses a character string into a safe integer
|===

=== Literals

[cols="1,2", options="header"]
|===
| Literal | Description

| xref:literals.adoc[`_u8`, `_u16`, `_u32`, `_u64`, `_u128`]
| User-defined literal suffixes for constructing safe integer types
|===

=== Stream I/O

[cols="1,2", options="header"]
|===
| Function | Description

| xref:iostream.adoc[`operator<<`, `operator>>`]
| Stream insertion and extraction for all safe integer types
|===

=== Bit Manipulation

[cols="1,2", options="header"]
|===
| Function | Description

| xref:bit.adoc[`has_single_bit`]
| Returns `true` if the value is a power of two

| xref:bit.adoc[`bit_ceil`]
| Returns the smallest power of two not less than the value

| xref:bit.adoc[`bit_floor`]
| Returns the largest power of two not greater than the value

| xref:bit.adoc[`bit_width`]
| Returns the number of bits needed to represent the value

| xref:bit.adoc[`rotl`]
| Bitwise left rotation

| xref:bit.adoc[`rotr`]
| Bitwise right rotation

| xref:bit.adoc[`countl_zero`]
| Counts consecutive zero bits from the most significant bit

| xref:bit.adoc[`countl_one`]
| Counts consecutive one bits from the most significant bit

| xref:bit.adoc[`countr_zero`]
| Counts consecutive zero bits from the least significant bit

| xref:bit.adoc[`countr_one`]
| Counts consecutive one bits from the least significant bit

| xref:bit.adoc[`popcount`]
| Returns the number of set bits

| xref:bit.adoc[`byteswap`]
| Reverses the bytes of the value
|===

=== Integer Utilities

[cols="1,2", options="header"]
|===
| Function | Description

| xref:integer_utilities.adoc[`isqrt`]
| Returns the integer square root (floor of sqrt) of a safe unsigned integer

| xref:integer_utilities.adoc[`remove_trailing_zeros`]
| Branchlessly removes trailing decimal zeros from a safe unsigned integer

| xref:integer_utilities.adoc[`is_power_10`]
| Tests whether a safe unsigned integer is an exact power of 10

| xref:integer_utilities.adoc[`is_power_2`]
| Tests whether a safe unsigned integer is an exact power of 2

| xref:integer_utilities.adoc[`ipow`]
| Integer exponentiation by squaring

| xref:integer_utilities.adoc[`log2`]
| Returns the floor of the base-2 logarithm
|===

=== Arithmetic

[cols="1,2", options="header"]
|===
| Function | Description

| xref:policies.adoc[`saturating_add`, `saturating_sub`, `saturating_mul`, `saturating_div`, `saturating_mod`]
| Saturating arithmetic (clamp to min/max on overflow)

| xref:policies.adoc[`overflowing_add`, `overflowing_sub`, `overflowing_mul`, `overflowing_div`, `overflowing_mod`]
| Overflowing arithmetic (wrap and return overflow flag)

| xref:policies.adoc[`checked_add`, `checked_sub`, `checked_mul`, `checked_div`, `checked_mod`]
| Checked arithmetic (return `std::nullopt` on overflow)

| xref:policies.adoc[`wrapping_add`, `wrapping_sub`, `wrapping_mul`, `wrapping_div`, `wrapping_mod`]
| Wrapping arithmetic (wrap silently)

| xref:policies.adoc[`strict_add`, `strict_sub`, `strict_mul`, `strict_div`, `strict_mod`]
| Strict arithmetic (call `std::exit(EXIT_FAILURE)` on error)

| xref:policies.adoc[`add`, `sub`, `mul`, `div`, `mod`]
| Generic policy-parameterized arithmetic (takes `overflow_policy` as template parameter)
|===

[#api_headers]
== Headers

[cols="1,2", options="header"]
|===
| Header | Contents

| `<boost/safe_numbers.hpp>`
| Convenience header including all library types

| `<boost/safe_numbers/bit.hpp>`
| Bit manipulation functions (`has_single_bit`, `bit_ceil`, `bit_floor`, `bit_width`, `rotl`, `rotr`, `countl_zero`, `countl_one`, `countr_zero`, `countr_one`, `popcount`, `byteswap`)

| `<boost/safe_numbers/charconv.hpp>`
| Character conversion functions (`to_chars`, `from_chars`)

| `<boost/safe_numbers/fmt_format.hpp`>
| Support for library types to `pass:[{fmt}]`.
This header is not included in the convenience header since it requires external dependencies

| `<boost/safe_numbers/format.hpp>`
| Contains specializations of `<format>` for library types

| `<boost/safe_numbers/integer_utilities.hpp>`
| Integer utility functions (`isqrt`, `remove_trailing_zeros`, `is_power_10`, `is_power_2`, `ipow`, `log2`)

| `<boost/safe_numbers/iostream.hpp>`
| Stream I/O operators (`operator<<`, `operator>>`) for library types

| `<boost/safe_numbers/limits.hpp>`
| Contains specializations of `<limits>` for library types

| `<boost/safe_numbers/literals.hpp>`
| User-defined literal suffixes (`_u8`, `_u16`, `_u32`, `_u64`, `_u128`)

| `<boost/safe_numbers/overflow_policy.hpp>`
| The `overflow_policy` enum class

| `<boost/safe_numbers/unsigned_integers.hpp>`
| All unsigned safe integer types (`u8`, `u16`, `u32`, `u64`, `u128`)

| `<boost/safe_numbers/bounded_integers.hpp>`
| Bounded unsigned integer type (`bounded_uint<Min, Max>`)

| `<boost/safe_numbers/verified_integers.hpp>`
| Verified integer types (`verified_u8`, `verified_u16`, `verified_u32`, `verified_u64`, `verified_u128`, `verified_bounded_integer<Min, Max>`)
|===
