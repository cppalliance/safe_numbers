////
Copyright 2026 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#bit]
= `<bit>` Support
:idprefix: bit_

== Description

The library provides thin wrappers around the C++20 https://en.cppreference.com/w/cpp/header/bit.html[`<bit>`] functions for all safe integer types, including `bounded_uint<Min, Max>`.
Each function extracts the underlying value, delegates to the corresponding `std::` function, and wraps the result back into the safe type where appropriate.
For `u128`, the functions delegate to the `boost::int128` implementations.

[source,c++]
----
#include <boost/safe_numbers/bit.hpp>
----

== Power-of-Two Functions

=== has_single_bit

[source,c++]
----
template <unsigned_library_type UnsignedInt>
constexpr auto has_single_bit(UnsignedInt x) noexcept -> bool;
----

Returns `true` if `x` is a power of two.
See https://en.cppreference.com/w/cpp/numeric/has_single_bit.html[`std::has_single_bit`].

=== bit_ceil

[source,c++]
----
template <unsigned_library_type UnsignedInt>
constexpr auto bit_ceil(UnsignedInt x) noexcept -> UnsignedInt;
----

Returns the smallest power of two not less than `x`.
Undefined behavior if the result is not representable in the underlying type.
See https://en.cppreference.com/w/cpp/numeric/bit_ceil.html[`std::bit_ceil`].

=== bit_floor

[source,c++]
----
template <unsigned_library_type UnsignedInt>
constexpr auto bit_floor(UnsignedInt x) noexcept -> UnsignedInt;
----

Returns the largest power of two not greater than `x`.
Returns zero if `x` is zero.
See https://en.cppreference.com/w/cpp/numeric/bit_floor.html[`std::bit_floor`].

=== bit_width

[source,c++]
----
template <unsigned_library_type UnsignedInt>
constexpr auto bit_width(UnsignedInt x) noexcept -> int;
----

Returns the number of bits needed to represent `x` (i.e., 1 + floor(log2(x)) for x > 0, or 0 for x == 0).
See https://en.cppreference.com/w/cpp/numeric/bit_width.html[`std::bit_width`].

== Rotation Functions

=== rotl

[source,c++]
----
template <non_bounded_unsigned_library_type UnsignedInt>
constexpr auto rotl(UnsignedInt x, int s) noexcept -> UnsignedInt;
----

Computes the result of bitwise left-rotating `x` by `s` positions.
See https://en.cppreference.com/w/cpp/numeric/rotl.html[`std::rotl`].

NOTE: `rotl` is not available for `bounded_uint` types. Bit rotation can produce values outside the valid bounded range, making the operation semantically meaningless for bounded integers.

=== rotr

[source,c++]
----
template <non_bounded_unsigned_library_type UnsignedInt>
constexpr auto rotr(UnsignedInt x, int s) noexcept -> UnsignedInt;
----

Computes the result of bitwise right-rotating `x` by `s` positions.
See https://en.cppreference.com/w/cpp/numeric/rotr.html[`std::rotr`].

NOTE: `rotr` is not available for `bounded_uint` types. Bit rotation can produce values outside the valid bounded range, making the operation semantically meaningless for bounded integers.

== Counting Functions

=== countl_zero

[source,c++]
----
template <unsigned_library_type UnsignedInt>
constexpr auto countl_zero(UnsignedInt x) noexcept -> int;
----

Returns the number of consecutive 0-bits starting from the most significant bit.
See https://en.cppreference.com/w/cpp/numeric/countl_zero.html[`std::countl_zero`].

=== countl_one

[source,c++]
----
template <unsigned_library_type UnsignedInt>
constexpr auto countl_one(UnsignedInt x) noexcept -> int;
----

Returns the number of consecutive 1-bits starting from the most significant bit.
See https://en.cppreference.com/w/cpp/numeric/countl_one.html[`std::countl_one`].

=== countr_zero

[source,c++]
----
template <unsigned_library_type UnsignedInt>
constexpr auto countr_zero(UnsignedInt x) noexcept -> int;
----

Returns the number of consecutive 0-bits starting from the least significant bit.
See https://en.cppreference.com/w/cpp/numeric/countr_zero.html[`std::countr_zero`].

=== countr_one

[source,c++]
----
template <unsigned_library_type UnsignedInt>
constexpr auto countr_one(UnsignedInt x) noexcept -> int;
----

Returns the number of consecutive 1-bits starting from the least significant bit.
See https://en.cppreference.com/w/cpp/numeric/countr_one.html[`std::countr_one`].

=== popcount

[source,c++]
----
template <unsigned_library_type UnsignedInt>
constexpr auto popcount(UnsignedInt x) noexcept -> int;
----

Returns the number of 1-bits in `x`.
See https://en.cppreference.com/w/cpp/numeric/popcount.html[`std::popcount`].

== Byte Manipulation

=== byteswap

[source,c++]
----
template <non_bounded_unsigned_library_type UnsignedInt>
constexpr auto byteswap(UnsignedInt x) noexcept -> UnsignedInt;
----

Reverses the bytes of `x`.
For standard unsigned types this delegates to `std::byteswap` (C++23).
For `u128` this delegates to the `boost::int128::byteswap` implementation.
See https://en.cppreference.com/w/cpp/numeric/byteswap.html[`std::byteswap`].

NOTE: `byteswap` is not available for `bounded_uint` types. Byte reversal can produce values outside the valid bounded range, making the operation semantically meaningless for bounded integers.

== Verified Types

The bit functions have special behavior with xref:verified_integers.adoc[verified types]:

Functions that return `int` or `bool` (`has_single_bit`, `bit_width`, `countl_zero`, `countl_one`, `countr_zero`, `countr_one`, `popcount`) work at runtime with verified types.
These functions only read the value via the `constexpr` conversion operator.

Functions that return the safe type (`bit_ceil`, `bit_floor`, `rotl`, `rotr`, `byteswap`) have `consteval` overloads for verified types, meaning they can only be called at compile time.
The `consteval` overloads use a `requires` clause to distinguish them:

[source,c++]
----
// Runtime overload (non-verified types)
template <unsigned_library_type UnsignedInt>
    requires (!is_verified_type_v<UnsignedInt>)
constexpr auto bit_ceil(UnsignedInt x) noexcept -> UnsignedInt;

// Compile-time overload (verified types only)
template <unsigned_library_type UnsignedInt>
    requires is_verified_type_v<UnsignedInt>
consteval auto bit_ceil(UnsignedInt x) noexcept -> UnsignedInt;
----

The same pattern applies to `bit_floor`, `rotl`, `rotr`, and `byteswap`.

== Examples

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/bit.cpp[example] demonstrates the bit manipulation functions.
====
[source, c++]
----
include::example$bit.cpp[]
----

Output:
----
has_single_bit(40) = 0
has_single_bit(32) = 1
bit_ceil(40)       = 64
bit_floor(40)      = 32
bit_width(40)      = 6

rotl(0b10110001, 2) = 198
rotr(0b10110001, 2) = 108

countl_zero(0x0F00) = 4
countl_one(0x0F00)  = 0
countr_zero(0x0F00) = 8
countr_one(0x0F00)  = 0
popcount(0x0F00)    = 4

byteswap(0x12345678) = 0x78563412

bounded has_single_bit(40) = 0
bounded bit_ceil(40)       = 64
bounded bit_floor(40)      = 32
bounded bit_width(40)      = 6
bounded popcount(40)       = 2
bounded countl_zero(0x0F00) = 4
bounded popcount(0x0F00)    = 4
----
====
