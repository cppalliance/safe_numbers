////
Copyright 2025 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#examples]
= Examples
:idprefix: examples_

All the following examples can be found in the examples/ folder of the library.

[#examples_basic_usage]
== Basic Usage (Default Throwing Behavior)

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/basic_usage.cpp[example] demonstrates the default behavior where arithmetic overflow throws an exception.
====
[source, c++]
----
include::example$basic_usage.cpp[]
----

Output:
----
Error Detected: Overflow detected in unsigned addition
----
====

[#examples_construction]
== Construction and Conversion

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/construction_and_conversion.cpp[example] demonstrates safe integer construction and conversion.
====
[source, c++]
----
include::example$construction_and_conversion.cpp[]
----

Output:
----
Safe Value: 42
Builtin Value: 42
----
====

[#examples_saturating]
== Saturating Arithmetic

Saturating arithmetic clamps results to the type's minimum or maximum value instead of overflowing or throwing.
This is useful when you want bounded behavior without exceptions.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/saturating_arithmetic.cpp[example] demonstrates saturating arithmetic operations.
====
[source, c++]
----
include::example$saturating_arithmetic.cpp[]
----

Output:
----
saturating_add(max, 100) = 4294967295
saturating_sub(10, 100) = 0
saturating_mul(max, 2) = 4294967295
saturating_add(100, 50) = 150
saturating_sub(100, 50) = 50
saturating_mul(100, 50) = 5000
----
====

[#examples_overflowing]
== Overflowing Arithmetic

Overflowing arithmetic returns both the wrapped result and a boolean flag indicating whether overflow occurred.
This gives you access to both the C-style wrapped value and overflow detection in a single operation.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/overflowing_arithmetic.cpp[example] demonstrates overflowing arithmetic operations.
====
[source, c++]
----
include::example$overflowing_arithmetic.cpp[]
----

Output:
----
overflowing_add(max, 100):
  result = 99
  overflowed = true
overflowing_sub(10, 100):
  result = 4294967206
  underflowed = true
overflowing_mul(max, 2):
  result = 4294967294
  overflowed = true
overflowing_add(100, 50) = 150 (overflow: false)
overflowing_sub(100, 50) = 50 (overflow: false)
overflowing_mul(100, 50) = 5000 (overflow: false)
Safe multiplication: 1000000000 * 5 = 5000000000
----
====

[#examples_checked]
== Checked Arithmetic

Checked arithmetic returns `std::optional` - containing the result on success, or `std::nullopt` on overflow.
This provides exception-free error handling with a clean, idiomatic interface.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/checked_arithmetic.cpp[example] demonstrates checked arithmetic operations.
====
[source, c++]
----
include::example$checked_arithmetic.cpp[]
----

Output:
----
checked_add(max, 100) = overflow detected!
checked_sub(10, 100) = underflow detected!
checked_div(100, 0) = division by zero!
checked_add(100, 50) = 150
checked_sub(100, 50) = 50
checked_mul(100, 50) = 5000
Safe: 1000000000 * 5 = 5000000000
----
====

[#examples_wrapping]
== Wrapping Arithmetic

Wrapping arithmetic performs standard C unsigned integer wrapping behavior - results wrap around modulo 2^N.
This matches the behavior of built-in unsigned integers and is useful for implementing counters, checksums, or hash functions.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/wrapping_arithmetic.cpp[example] demonstrates wrapping arithmetic operations.
====
[source, c++]
----
include::example$wrapping_arithmetic.cpp[]
----

Output:
----
wrapping_add(255, 2) = 1
wrapping_sub(0, 1) = 255
wrapping_mul(200, 2) = 144
wrapping_add(UINT32_MAX, 1) = 0
wrapping_sub(0, 1) = 4294967295
wrapping_add(100, 50) = 150
wrapping_sub(100, 50) = 50
wrapping_mul(100, 50) = 5000
Counter sequence: 254 255 0 1 2
----
====

[#examples_strict]
== Strict Arithmetic

Strict arithmetic calls `std::exit(EXIT_FAILURE)` on overflow, underflow, or division by zero.
This provides a hard termination policy for safety-critical applications where exceptions cannot be used but silent wrapping is unacceptable.
All strict functions are `noexcept`.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/strict_arithmetic.cpp[example] demonstrates strict arithmetic operations.
====
[source, c++]
----
include::example$strict_arithmetic.cpp[]
----

Output:
----
strict_add(100, 50) = 150
strict_sub(100, 50) = 50
strict_mul(100, 50) = 5000
strict_div(100, 50) = 2
strict_mod(100, 50) = 0
strict_div(1000000, 3) = 333333
strict_mod(1000000, 3) = 1
----
====

[#examples_generic]
== Generic Policy-Parameterized Arithmetic

The generic `add`, `sub`, `mul`, `div`, and `mod` functions accept an `overflow_policy` as a template parameter, allowing you to write code that is generic over the overflow handling strategy.
The return type varies by policy.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/generic_arithmetic.cpp[example] demonstrates the generic policy-parameterized interface.
====
[source, c++]
----
include::example$generic_arithmetic.cpp[]
----

Output:
----
add<throw_exception>(100, 50) = 150
add<saturate>(100, 50)        = 150
add<wrapping>(100, 50)        = 150
add<strict>(100, 50)          = 150
add<overflow_tuple>(100, 50)   = 150 (overflowed: false)
add<checked>(100, 50)          = 150
add<checked>(max, 1)           = nullopt (overflow)
add<saturate>(max, 1)          = 4294967295
add<wrapping>(max, 1)          = 0
----
====

[#examples_charconv]
== Character Conversion

The library provides `to_chars` and `from_chars` functions for converting between safe integers and strings using https://www.boost.org/doc/libs/master/libs/charconv/doc/html/charconv.html[Boost.Charconv].

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/charconv.cpp[example] demonstrates character conversion with various bases.
====
[source, c++]
----
include::example$charconv.cpp[]
----

Output:
----
to_chars (base 10): 12345
to_chars (base 16): 3039
to_chars (base 2):  11000000111001

from_chars (base 10): 98765
from_chars (base 16): 6699
from_chars (base 2):  26
----
====

[#examples_fmt_format]
== Formatting with pass:[{fmt}]

The library supports formatting with both `<format>` (C++20) and `<fmt/format.h>`.
All standard integer format specifiers are supported.

IMPORTANT: The header `<boost/safe_numbers/fmt_format.hpp>` is *NOT* part of the convenience header, because it is an optional dependency.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/fmt_format.cpp[example] demonstrates formatting with pass:[{fmt}].
====
[source, c++]
----
include::example$fmt_format.cpp[]
----

Output:
----
Default Format:
12345
9876543210

Hexadecimal Format:
3039
0x24cb016ea

Binary Format:
11000000111001
0b101010

Octal Format:
30071
030071

Padding and Alignment:
     12345
12345
  12345
0000012345

Fill Character:
*****12345
12345_____
----
====

[#examples_policy_comparison]
== Policy Comparison

The following table summarizes the behavior of each arithmetic policy:

[cols="1,2,2,2"]
|===
|Policy |On Overflow |Return Type |Use Case

|Default (operators)
|Throws `std::overflow_error`
|`T`
|When overflow is a programming error

|Saturating
|Clamps to min/max
|`T`
|Bounded values, DSP, graphics

|Overflowing
|Returns wrapped value + flag
|`std::pair<T, bool>`
|Need both wrapped value and detection

|Checked
|Returns `std::nullopt`
|`std::optional<T>`
|Exception-free error handling

|Wrapping
|Wraps around (modulo 2^N)
|`T`
|Counters, checksums, hashing

|Strict
|Calls `std::exit(EXIT_FAILURE)`
|`T`
|Safety-critical, no-exceptions environments

|Generic (`add<Policy>`)
|Depends on policy
|Depends on policy
|Policy-generic algorithms
|===
