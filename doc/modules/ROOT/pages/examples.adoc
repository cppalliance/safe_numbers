////
Copyright 2025 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#examples]
= Examples
:idprefix: examples_

All the following examples can be found in the examples/ folder of the library.

[#examples_basic_usage]
== Basic Usage (Default Throwing Behavior)

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/basic_usage.cpp[example] demonstrates the default behavior where arithmetic overflow throws an exception.
====
[source, c++]
----
include::example$basic_usage.cpp[]
----

Output:
----
Error Detected: Overflow detected in unsigned addition
----
====

[#examples_construction]
== Construction and Conversion

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/construction_and_conversion.cpp[example] demonstrates safe integer construction and conversion.
====
[source, c++]
----
include::example$construction_and_conversion.cpp[]
----

Output:
----
Safe Value: 42
Builtin Value: 42
----
====

[#examples_saturating]
== Saturating Arithmetic

Saturating arithmetic clamps results to the type's minimum or maximum value instead of overflowing or throwing.
This is useful when you want bounded behavior without exceptions.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/saturating_arithmetic.cpp[example] demonstrates saturating arithmetic operations.
====
[source, c++]
----
include::example$saturating_arithmetic.cpp[]
----

Output:
----
saturating_add(max, 100) = 4294967295
saturating_sub(10, 100) = 0
saturating_mul(max, 2) = 4294967295
saturating_add(100, 50) = 150
saturating_sub(100, 50) = 50
saturating_mul(100, 50) = 5000
----
====

[#examples_overflowing]
== Overflowing Arithmetic

Overflowing arithmetic returns both the wrapped result and a boolean flag indicating whether overflow occurred.
This gives you access to both the C-style wrapped value and overflow detection in a single operation.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/overflowing_arithmetic.cpp[example] demonstrates overflowing arithmetic operations.
====
[source, c++]
----
include::example$overflowing_arithmetic.cpp[]
----

Output:
----
overflowing_add(max, 100):
  result = 99
  overflowed = true
overflowing_sub(10, 100):
  result = 4294967206
  underflowed = true
overflowing_mul(max, 2):
  result = 4294967294
  overflowed = true
overflowing_add(100, 50) = 150 (overflow: false)
overflowing_sub(100, 50) = 50 (overflow: false)
overflowing_mul(100, 50) = 5000 (overflow: false)
Safe multiplication: 1000000000 * 5 = 5000000000
----
====

[#examples_checked]
== Checked Arithmetic

Checked arithmetic returns `std::optional` - containing the result on success, or `std::nullopt` on overflow.
This provides exception-free error handling with a clean, idiomatic interface.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/checked_arithmetic.cpp[example] demonstrates checked arithmetic operations.
====
[source, c++]
----
include::example$checked_arithmetic.cpp[]
----

Output:
----
checked_add(max, 100) = overflow detected!
checked_sub(10, 100) = underflow detected!
checked_div(100, 0) = division by zero!
checked_add(100, 50) = 150
checked_sub(100, 50) = 50
checked_mul(100, 50) = 5000
Safe: 1000000000 * 5 = 5000000000
----
====

[#examples_wrapping]
== Wrapping Arithmetic

Wrapping arithmetic performs standard C unsigned integer wrapping behavior - results wrap around modulo 2^N.
This matches the behavior of built-in unsigned integers and is useful for implementing counters, checksums, or hash functions.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/wrapping_arithmetic.cpp[example] demonstrates wrapping arithmetic operations.
====
[source, c++]
----
include::example$wrapping_arithmetic.cpp[]
----

Output:
----
wrapping_add(255, 2) = 1
wrapping_sub(0, 1) = 255
wrapping_mul(200, 2) = 144
wrapping_add(UINT32_MAX, 1) = 0
wrapping_sub(0, 1) = 4294967295
wrapping_add(100, 50) = 150
wrapping_sub(100, 50) = 50
wrapping_mul(100, 50) = 5000
Counter sequence: 254 255 0 1 2
----
====

[#examples_strict]
== Strict Arithmetic

Strict arithmetic calls `std::exit(EXIT_FAILURE)` on overflow, underflow, or division by zero.
This provides a hard termination policy for safety-critical applications where exceptions cannot be used but silent wrapping is unacceptable.
All strict functions are `noexcept`.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/strict_arithmetic.cpp[example] demonstrates strict arithmetic operations.
====
[source, c++]
----
include::example$strict_arithmetic.cpp[]
----

Output:
----
strict_add(100, 50) = 150
strict_sub(100, 50) = 50
strict_mul(100, 50) = 5000
strict_div(100, 50) = 2
strict_mod(100, 50) = 0
strict_div(1000000, 3) = 333333
strict_mod(1000000, 3) = 1
----
====

[#examples_generic]
== Generic Policy-Parameterized Arithmetic

The generic `add`, `sub`, `mul`, `div`, and `mod` functions accept an `overflow_policy` as a template parameter, allowing you to write code that is generic over the overflow handling strategy.
The return type varies by policy.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/generic_arithmetic.cpp[example] demonstrates the generic policy-parameterized interface.
====
[source, c++]
----
include::example$generic_arithmetic.cpp[]
----

Output:
----
add<throw_exception>(100, 50) = 150
add<saturate>(100, 50)        = 150
add<wrapping>(100, 50)        = 150
add<strict>(100, 50)          = 150
add<overflow_tuple>(100, 50)   = 150 (overflowed: false)
add<checked>(100, 50)          = 150
add<checked>(max, 1)           = nullopt (overflow)
add<saturate>(max, 1)          = 4294967295
add<wrapping>(max, 1)          = 0
----
====

[#examples_literals]
== Literals

User-defined literal suffixes (`_u8`, `_u16`, `_u32`, `_u64`, `_u128`) provide concise construction of safe integer types.
Values are range-checked at construction, producing a compile error in `constexpr` contexts or throwing `std::overflow_error` at runtime for out-of-range values.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/literals.cpp[example] demonstrates how to use user-defined literals with safe integer types.
====
[source, c++]
----
include::example$literals.cpp[]
----

Output:
----
42_u8   = 42
1000_u16 = 1000
100000_u32 = 100000
9999999999_u64 = 9999999999
max_u128 = 340282366920938463463374607431768211455
100_u32 + 50_u32 = 150
6_u32 * 7_u32    = 42
constexpr 255_u8 = 255
----
====

[#examples_charconv]
== Character Conversion

The library provides `to_chars` and `from_chars` functions for converting between safe integers and strings using https://www.boost.org/doc/libs/master/libs/charconv/doc/html/charconv.html[Boost.Charconv].

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/charconv.cpp[example] demonstrates character conversion with various bases.
====
[source, c++]
----
include::example$charconv.cpp[]
----

Output:
----
to_chars (base 10): 12345
to_chars (base 16): 3039
to_chars (base 2):  11000000111001

from_chars (base 10): 98765
from_chars (base 16): 6699
from_chars (base 2):  26
----
====

[#examples_fmt_format]
== Formatting with pass:[{fmt}]

The library supports formatting with both `<format>` (C++20) and `<fmt/format.h>`.
All standard integer format specifiers are supported.

IMPORTANT: The header `<boost/safe_numbers/fmt_format.hpp>` is *NOT* part of the convenience header, because it is an optional dependency.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/fmt_format.cpp[example] demonstrates formatting with pass:[{fmt}].
====
[source, c++]
----
include::example$fmt_format.cpp[]
----

Output:
----
Default Format:
12345
9876543210

Hexadecimal Format:
3039
0x24cb016ea

Binary Format:
11000000111001
0b101010

Octal Format:
30071
030071

Padding and Alignment:
     12345
12345
  12345
0000012345

Fill Character:
*****12345
12345_____
----
====

[#examples_iostream]
== Stream I/O

The library provides `operator<<` and `operator>>` overloads for all safe integer types.
The `u8` type is handled specially: it displays as a numeric value rather than as a character.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/iostream.cpp[example] demonstrates stream I/O with safe integer types.
====
[source, c++]
----
include::example$iostream.cpp[]
----

Output:
----
u8:  42
u16: 1000
u32: 100000
u64: 9999999999
u8(10) = 10 (not a newline character)
u8(32) = 32 (not a space character)
Read from stream: 12345
Decimal:     255
Hexadecimal: ff
Octal:       377
Roundtrip: 18446744073709551615 -> "18446744073709551615" -> 18446744073709551615
----
====

[#examples_bit]
== Bit Manipulation

The library provides thin wrappers around all C++20 `<bit>` functions for safe integer types.
Each function extracts the underlying value, delegates to the standard library, and wraps the result back.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/bit.cpp[example] demonstrates the bit manipulation functions.
====
[source, c++]
----
include::example$bit.cpp[]
----

Output:
----
has_single_bit(40) = 0
has_single_bit(32) = 1
bit_ceil(40)       = 64
bit_floor(40)      = 32
bit_width(40)      = 6

rotl(0b10110001, 2) = 198
rotr(0b10110001, 2) = 108

countl_zero(0x0F00) = 4
countl_one(0x0F00)  = 0
countr_zero(0x0F00) = 8
countr_one(0x0F00)  = 0
popcount(0x0F00)    = 4

byteswap(0x12345678) = 0x78563412
----
====

[#examples_bitwise_ops]
== Bitwise Operations

The library provides bitwise operators (`~`, `&`, `|`, `^`, `<<`, `>>`) and their compound assignment forms (`&=`, `|=`, `^=`, `<<=`, `>>=`).
The NOT, AND, OR, and XOR operators are `noexcept`, while the shift operators throw `std::overflow_error` if bits would be shifted past the type width.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/bitwise_ops.cpp[example] demonstrates the bitwise operators and shift overflow detection.
====
[source, c++]
----
include::example$bitwise_ops.cpp[]
----

Output:
----
~a             = 0xff00ff
a & b          = 0xf000f00
a | b          = 0xff0fff0f
a ^ b          = 0xf00ff00f

u8(1) << 4     = 16
u8(128) >> 4   = 8

x &= 0x0F0F   -> 0xf00
x |= 0xF000   -> 0xff00
x ^= 0x00FF   -> 0xffff
y <<= 8       -> 256
y >>= 4       -> 16

Left shift error: Left shift past the end of the type width
Right shift error: Right shift past the end of the type width

saturating_shl(u8(1), 4)    = 16
saturating_shl(u8(255), 1)  = 255
saturating_shr(u8(128), 4)  = 8
saturating_shr(u8(1), 8)    = 0

overflowing_shl(u8(255), 1) = 254 (overflow: true)
overflowing_shr(u8(1), 8)   = 0 (overflow: true)

checked_shl(u8(1), 4)       = 16
checked_shl(u8(255), 1)     = nullopt (overflow)
checked_shr(u8(1), 8)       = nullopt (overflow)

wrapping_shl(u8(255), 1)    = 254
wrapping_shr(u8(1), 8)      = 0

shl<saturate>(u32(1), 30)   = 1073741824
shl<saturate>(u32(max), 1)  = 4294967295
shr<checked>(u32(8), 1)     = 4
----
====

[#examples_verified_construction]
== Verified Types: Construction and Runtime Usage

Verified types use `consteval` constructors and arithmetic, guaranteeing that all values are validated at compile time.
At runtime, verified types are read-only constants that support output streaming, explicit conversions, and comparisons.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/verified_construction.cpp[example] demonstrates construction and runtime use of verified types.
====
[source, c++]
----
include::example$verified_construction.cpp[]
----

Output:
----
verified_u8:  42
verified_u16: 1000
verified_u32: 100000
verified_u64: 9999999999
verified_u32: 42

Converted to uint32_t: 100000
42 < 1000: true
42 == 42: true

percent: 50
----
====

[#examples_verified_arithmetic]
== Verified Types: Compile-Time Arithmetic

All arithmetic on verified types (`+`, `-`, `*`, `/`, `%`, `+=`, `++`, etc.) is `consteval` -- evaluated entirely by the compiler.
If an operation overflows, it produces a compile error instead of a runtime exception.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/verified_arithmetic.cpp[example] demonstrates compile-time arithmetic with verified types.
====
[source, c++]
----
include::example$verified_arithmetic.cpp[]
----

Output:
----
100 + 200 = 300
200 - 100 = 100
15  * 20  = 300
300 / 10  = 30
17  % 5   = 2

10 after ++: 11
0 + 100 + 200 + 300 = 600

bounded 500 + 400 = 900
----
====

[#examples_verified_runtime]
== Verified Types: Runtime Capabilities

While construction and arithmetic are compile-time only, verified types support a wide range of runtime operations:
output streaming, explicit conversions, comparisons, `to_chars`, bit queries, and `std::numeric_limits`.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/verified_runtime_usage.cpp[example] shows what verified types can do at runtime.
====
[source, c++]
----
include::example$verified_runtime_usage.cpp[]
----

Output:
----
Value: 1024
As uint32_t: 1024
As u32: 1024

10 == 10:    true
10 != 50000: true
10 <  50000: true
10 >= 50000: false

to_chars (base 10): 1024
to_chars (base 16): 400

has_single_bit(1024) = true
bit_width(1024)      = 11
countl_zero(1024)    = 21
popcount(1024)       = 1
bit_ceil(48)         = 64
bit_floor(48)        = 32

numeric_limits<verified_u8>::min()  = 0
numeric_limits<verified_u8>::max()  = 255
numeric_limits<verified_u32>::digits = 32
----
====

[#examples_verified_compile_fail]
== Verified Types: Compile-Time Overflow Detection

Verified types catch overflow at compile time.
Attempting to overflow a verified type produces a compiler error rather than a runtime exception.

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/compile_fail_verified_overflow.cpp[example] fails to compile because `u8(255) + u8(1)` overflows.
====
[source, c++]
----
include::example$compile_fail_verified_overflow.cpp[]
----
====

[#examples_policy_comparison]
== Policy Comparison

The following table summarizes the behavior of each arithmetic policy:

[cols="1,2,2,2"]
|===
|Policy |On Overflow |Return Type |Use Case

|Default (operators)
|Throws `std::overflow_error`
|`T`
|When overflow is a programming error

|Saturating
|Clamps to min/max
|`T`
|Bounded values, DSP, graphics

|Overflowing
|Returns wrapped value + flag
|`std::pair<T, bool>`
|Need both wrapped value and detection

|Checked
|Returns `std::nullopt`
|`std::optional<T>`
|Exception-free error handling

|Wrapping
|Wraps around (modulo 2^N)
|`T`
|Counters, checksums, hashing

|Strict
|Calls `std::exit(EXIT_FAILURE)`
|`T`
|Safety-critical, no-exceptions environments

|Generic (`add<Policy>`)
|Depends on policy
|Depends on policy
|Policy-generic algorithms
|===
