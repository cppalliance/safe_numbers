////
Copyright 2026 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#charconv]
= `<charconv>` Support
:idprefix: charconv_

== Description

The library provides character conversion functions for all safe integer types using https://www.boost.org/doc/libs/master/libs/charconv/doc/html/charconv.html[Boost.Charconv].
These functions convert between safe integer types (including `bounded_uint`) and their string representations.

Since Boost.Charconv is a compiled library, auto-linking may occur (Especially on MSVC platforms).
If you do not use Boost.Charconv in your application except for the dependency to this library, you can define the following:

[source, c++]
----
#define BOOST_CHARCONV_NO_LIB
#include <boost/safe_numbers.hpp> // or any other boost.safe_numbers header
----

`BOOST_CHARCONV_NO_LIB` must be defined before the inclusion of any boost.safe_numbers header.
This will disable auto-linking for Boost.Charconv.

[source,c++]
----
#include <boost/safe_numbers/charconv.hpp>

namespace boost::safe_numbers {

// Convert safe integer to character string
template <detail::library_type T>
constexpr auto to_chars(char* first, char* last,
                        T value,
                        int base = 10) -> charconv::to_chars_result;

// Convert character string to safe integer
template <detail::library_type T>
constexpr auto from_chars(const char* first, const char* last,
                          T& value,
                          int base = 10) -> charconv::from_chars_result;

} // namespace boost::safe_numbers
----

== to_chars_result

[source,c++]
----
namespace boost::charconv {

struct to_chars_result
{
    char* ptr;
    std::errc ec;

    friend constexpr bool operator==(const to_chars_result& lhs,
                                     const to_chars_result& rhs) noexcept = default;
    constexpr explicit operator bool() const noexcept { return ec == std::errc{}; }
};

} // namespace boost::charconv
----

|===
| Member | Description

| `ptr` | Pointer to one past the last character written on success, or `last` on failure
| `ec` | Error code: `std::errc{}` on success, `std::errc::value_too_large` if buffer is too small
|===

== from_chars_result

[source,c++]
----
namespace boost::charconv {

struct from_chars_result
{
    const char* ptr;
    std::errc ec;

    friend constexpr bool operator==(const from_chars_result& lhs,
                                     const from_chars_result& rhs) noexcept = default;
    constexpr explicit operator bool() const noexcept { return ec == std::errc{}; }
};

} // namespace boost::charconv
----

|===
| Member | Description

| `ptr` | Pointer to the first character not matching the pattern, or `last` if all matched
| `ec` | Error code: `std::errc{}` on success, `std::errc::invalid_argument` if no valid conversion, `std::errc::result_out_of_range` if value overflows
|===

== to_chars

[source,c++]
----
template <detail::library_type T>
constexpr auto to_chars(char* first, char* last,
                        T value,
                        int base = 10) -> charconv::to_chars_result;
----

Converts a safe integer value into a character buffer specified by `[first, last)`.
Works with all safe integer types, including `u8`, `u16`, `u32`, `u64`, `u128`, and `bounded_uint<Min, Max>`.

=== Parameters

|===
| Parameter | Description

| `first`, `last` | Character buffer to write to
| `value` | The safe integer value to convert
| `base` | Integer base (default: 10), must be between 2 and 36
|===

=== Return Value

Returns `boost::charconv::to_chars_result` with:

- `ptr` pointing to one past the last character written on success
- `ec` set to `std::errc{}` on success, or `std::errc::value_too_large` if the buffer is too small

== from_chars

[source,c++]
----
template <detail::library_type T>
constexpr auto from_chars(const char* first, const char* last,
                          T& value,
                          int base = 10) -> charconv::from_chars_result;
----

Parses a string from `[first, last)` and converts it into a safe integer value.
Works with all safe integer types, including `u8`, `u16`, `u32`, `u64`, `u128`, and `bounded_uint<Min, Max>`.

=== Parameters

|===
| Parameter | Description

| `first`, `last` | Character range to parse
| `value` | Reference to safe integer to store the result
| `base` | Integer base (default: 10), must be between 2 and 36
|===

=== Return Value

Returns `boost::charconv::from_chars_result` with:

- `ptr` pointing to the first character not matching the pattern
- `ec` set to `std::errc{}` on success, `std::errc::invalid_argument` if no valid conversion, or `std::errc::result_out_of_range` if the value overflows

== Examples

.This https://github.com/boostorg/safe_numbers/blob/develop/examples/charconv.cpp[example] demonstrates how to use `to_chars` and `from_chars` with safe integer types.
====
[source, c++]
----
include::example$charconv.cpp[]
----

Output:
----
to_chars (base 10): 12345
to_chars (base 16): 3039
to_chars (base 2):  11000000111001

from_chars (base 10): 98765
from_chars (base 16): 6699
from_chars (base 2):  26

bounded to_chars (percent): 75
bounded to_chars (port):    8080
bounded from_chars (percent): 42
bounded from_chars (port):    443
----
====
